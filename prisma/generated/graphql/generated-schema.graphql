# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AffectedRowsOutput {
  count: Int!
}

type AggregateProduct {
  _count: ProductCountAggregate
  _max: ProductMaxAggregate
  _min: ProductMinAggregate
}

type AggregatePurchase {
  _avg: PurchaseAvgAggregate
  _count: PurchaseCountAggregate
  _max: PurchaseMaxAggregate
  _min: PurchaseMinAggregate
  _sum: PurchaseSumAggregate
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input FloatFieldUpdateOperationsInput {
  decrement: Float
  divide: Float
  increment: Float
  multiply: Float
  set: Float
}

input FloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input FloatWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedFloatFilter
  _min: NestedFloatFilter
  _sum: NestedFloatFilter
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatWithAggregatesFilter
  notIn: [Float!]
}

type Mutation {
  createManyProduct(data: [ProductCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyPurchase(data: [PurchaseCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createProduct(data: ProductCreateInput!): Product!
  createPurchase(data: PurchaseCreateInput!): Purchase!
  deleteManyProduct(where: ProductWhereInput): AffectedRowsOutput!
  deleteManyPurchase(where: PurchaseWhereInput): AffectedRowsOutput!
  deleteProduct(where: ProductWhereUniqueInput!): Product
  deletePurchase(where: PurchaseWhereUniqueInput!): Purchase
  updateManyProduct(data: ProductUpdateManyMutationInput!, where: ProductWhereInput): AffectedRowsOutput!
  updateManyPurchase(data: PurchaseUpdateManyMutationInput!, where: PurchaseWhereInput): AffectedRowsOutput!
  updateProduct(data: ProductUpdateInput!, where: ProductWhereUniqueInput!): Product
  updatePurchase(data: PurchaseUpdateInput!, where: PurchaseWhereUniqueInput!): Purchase
  upsertProduct(create: ProductCreateInput!, update: ProductUpdateInput!, where: ProductWhereUniqueInput!): Product!
  upsertPurchase(create: PurchaseCreateInput!, update: PurchaseUpdateInput!, where: PurchaseWhereUniqueInput!): Purchase!
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedFloatWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedFloatFilter
  _min: NestedFloatFilter
  _sum: NestedFloatFilter
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatWithAggregatesFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

type Product {
  _count: ProductCount
  createdAt: DateTime!
  id: String!
  images: [String!]!
  merchant: String
  title: String
  updatedAt: DateTime!
  url: String
}

type ProductCount {
  purchases: Int!
}

type ProductCountAggregate {
  _all: Int!
  createdAt: Int!
  id: Int!
  images: Int!
  merchant: Int!
  title: Int!
  updatedAt: Int!
  url: Int!
}

input ProductCountOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  images: SortOrder
  merchant: SortOrder
  title: SortOrder
  updatedAt: SortOrder
  url: SortOrder
}

input ProductCreateimagesInput {
  set: [String!]!
}

input ProductCreateInput {
  createdAt: DateTime
  id: String
  images: ProductCreateimagesInput
  merchant: String
  purchases: PurchaseCreateNestedManyWithoutProductInput
  title: String
  updatedAt: DateTime
  url: String
}

input ProductCreateManyInput {
  createdAt: DateTime
  id: String
  images: ProductCreateimagesInput
  merchant: String
  title: String
  updatedAt: DateTime
  url: String
}

input ProductCreateNestedOneWithoutPurchasesInput {
  connect: ProductWhereUniqueInput
  connectOrCreate: ProductCreateOrConnectWithoutPurchasesInput
  create: ProductCreateWithoutPurchasesInput
}

input ProductCreateOrConnectWithoutPurchasesInput {
  create: ProductCreateWithoutPurchasesInput!
  where: ProductWhereUniqueInput!
}

input ProductCreateWithoutPurchasesInput {
  createdAt: DateTime
  id: String
  images: ProductCreateimagesInput
  merchant: String
  title: String
  updatedAt: DateTime
  url: String
}

type ProductGroupBy {
  _count: ProductCountAggregate
  _max: ProductMaxAggregate
  _min: ProductMinAggregate
  createdAt: DateTime!
  id: String!
  images: [String!]
  merchant: String
  title: String
  updatedAt: DateTime!
  url: String
}

type ProductMaxAggregate {
  createdAt: DateTime
  id: String
  merchant: String
  title: String
  updatedAt: DateTime
  url: String
}

input ProductMaxOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  merchant: SortOrder
  title: SortOrder
  updatedAt: SortOrder
  url: SortOrder
}

type ProductMinAggregate {
  createdAt: DateTime
  id: String
  merchant: String
  title: String
  updatedAt: DateTime
  url: String
}

input ProductMinOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  merchant: SortOrder
  title: SortOrder
  updatedAt: SortOrder
  url: SortOrder
}

input ProductOrderByWithAggregationInput {
  _count: ProductCountOrderByAggregateInput
  _max: ProductMaxOrderByAggregateInput
  _min: ProductMinOrderByAggregateInput
  createdAt: SortOrder
  id: SortOrder
  images: SortOrder
  merchant: SortOrder
  title: SortOrder
  updatedAt: SortOrder
  url: SortOrder
}

input ProductOrderByWithRelationInput {
  createdAt: SortOrder
  id: SortOrder
  images: SortOrder
  merchant: SortOrder
  purchases: PurchaseOrderByRelationAggregateInput
  title: SortOrder
  updatedAt: SortOrder
  url: SortOrder
}

input ProductRelationFilter {
  is: ProductWhereInput
  isNot: ProductWhereInput
}

enum ProductScalarFieldEnum {
  createdAt
  id
  images
  merchant
  title
  updatedAt
  url
}

input ProductScalarWhereWithAggregatesInput {
  AND: [ProductScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  id: StringWithAggregatesFilter
  images: StringNullableListFilter
  merchant: StringNullableWithAggregatesFilter
  NOT: [ProductScalarWhereWithAggregatesInput!]
  OR: [ProductScalarWhereWithAggregatesInput!]
  title: StringNullableWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
  url: StringNullableWithAggregatesFilter
}

input ProductUpdateimagesInput {
  push: [String!]
  set: [String!]
}

input ProductUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  images: ProductUpdateimagesInput
  merchant: NullableStringFieldUpdateOperationsInput
  purchases: PurchaseUpdateManyWithoutProductInput
  title: NullableStringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  url: NullableStringFieldUpdateOperationsInput
}

input ProductUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  images: ProductUpdateimagesInput
  merchant: NullableStringFieldUpdateOperationsInput
  title: NullableStringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  url: NullableStringFieldUpdateOperationsInput
}

input ProductUpdateOneWithoutPurchasesInput {
  connect: ProductWhereUniqueInput
  connectOrCreate: ProductCreateOrConnectWithoutPurchasesInput
  create: ProductCreateWithoutPurchasesInput
  delete: Boolean
  disconnect: Boolean
  update: ProductUpdateWithoutPurchasesInput
  upsert: ProductUpsertWithoutPurchasesInput
}

input ProductUpdateWithoutPurchasesInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  images: ProductUpdateimagesInput
  merchant: NullableStringFieldUpdateOperationsInput
  title: NullableStringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  url: NullableStringFieldUpdateOperationsInput
}

input ProductUpsertWithoutPurchasesInput {
  create: ProductCreateWithoutPurchasesInput!
  update: ProductUpdateWithoutPurchasesInput!
}

input ProductWhereInput {
  AND: [ProductWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  images: StringNullableListFilter
  merchant: StringNullableFilter
  NOT: [ProductWhereInput!]
  OR: [ProductWhereInput!]
  purchases: PurchaseListRelationFilter
  title: StringNullableFilter
  updatedAt: DateTimeFilter
  url: StringNullableFilter
}

input ProductWhereUniqueInput {
  id: String
}

type Purchase {
  createdAt: DateTime!
  id: String!
  price: Float!
  productId: String
  updatedAt: DateTime!
}

type PurchaseAvgAggregate {
  price: Float
}

input PurchaseAvgOrderByAggregateInput {
  price: SortOrder
}

type PurchaseCountAggregate {
  _all: Int!
  createdAt: Int!
  id: Int!
  price: Int!
  productId: Int!
  updatedAt: Int!
}

input PurchaseCountOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  price: SortOrder
  productId: SortOrder
  updatedAt: SortOrder
}

input PurchaseCreateInput {
  createdAt: DateTime
  id: String
  price: Float!
  product: ProductCreateNestedOneWithoutPurchasesInput
  updatedAt: DateTime
}

input PurchaseCreateManyInput {
  createdAt: DateTime
  id: String
  price: Float!
  productId: String
  updatedAt: DateTime
}

input PurchaseCreateManyProductInput {
  createdAt: DateTime
  id: String
  price: Float!
  updatedAt: DateTime
}

input PurchaseCreateManyProductInputEnvelope {
  data: [PurchaseCreateManyProductInput!]!
  skipDuplicates: Boolean
}

input PurchaseCreateNestedManyWithoutProductInput {
  connect: [PurchaseWhereUniqueInput!]
  connectOrCreate: [PurchaseCreateOrConnectWithoutProductInput!]
  create: [PurchaseCreateWithoutProductInput!]
  createMany: PurchaseCreateManyProductInputEnvelope
}

input PurchaseCreateOrConnectWithoutProductInput {
  create: PurchaseCreateWithoutProductInput!
  where: PurchaseWhereUniqueInput!
}

input PurchaseCreateWithoutProductInput {
  createdAt: DateTime
  id: String
  price: Float!
  updatedAt: DateTime
}

type PurchaseGroupBy {
  _avg: PurchaseAvgAggregate
  _count: PurchaseCountAggregate
  _max: PurchaseMaxAggregate
  _min: PurchaseMinAggregate
  _sum: PurchaseSumAggregate
  createdAt: DateTime!
  id: String!
  price: Float!
  productId: String
  updatedAt: DateTime!
}

input PurchaseListRelationFilter {
  every: PurchaseWhereInput
  none: PurchaseWhereInput
  some: PurchaseWhereInput
}

type PurchaseMaxAggregate {
  createdAt: DateTime
  id: String
  price: Float
  productId: String
  updatedAt: DateTime
}

input PurchaseMaxOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  price: SortOrder
  productId: SortOrder
  updatedAt: SortOrder
}

type PurchaseMinAggregate {
  createdAt: DateTime
  id: String
  price: Float
  productId: String
  updatedAt: DateTime
}

input PurchaseMinOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  price: SortOrder
  productId: SortOrder
  updatedAt: SortOrder
}

input PurchaseOrderByRelationAggregateInput {
  _count: SortOrder
}

input PurchaseOrderByWithAggregationInput {
  _avg: PurchaseAvgOrderByAggregateInput
  _count: PurchaseCountOrderByAggregateInput
  _max: PurchaseMaxOrderByAggregateInput
  _min: PurchaseMinOrderByAggregateInput
  _sum: PurchaseSumOrderByAggregateInput
  createdAt: SortOrder
  id: SortOrder
  price: SortOrder
  productId: SortOrder
  updatedAt: SortOrder
}

input PurchaseOrderByWithRelationInput {
  createdAt: SortOrder
  id: SortOrder
  price: SortOrder
  product: ProductOrderByWithRelationInput
  productId: SortOrder
  updatedAt: SortOrder
}

enum PurchaseScalarFieldEnum {
  createdAt
  id
  price
  productId
  updatedAt
}

input PurchaseScalarWhereInput {
  AND: [PurchaseScalarWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  NOT: [PurchaseScalarWhereInput!]
  OR: [PurchaseScalarWhereInput!]
  price: FloatFilter
  productId: StringNullableFilter
  updatedAt: DateTimeFilter
}

input PurchaseScalarWhereWithAggregatesInput {
  AND: [PurchaseScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  id: StringWithAggregatesFilter
  NOT: [PurchaseScalarWhereWithAggregatesInput!]
  OR: [PurchaseScalarWhereWithAggregatesInput!]
  price: FloatWithAggregatesFilter
  productId: StringNullableWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type PurchaseSumAggregate {
  price: Float
}

input PurchaseSumOrderByAggregateInput {
  price: SortOrder
}

input PurchaseUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  price: FloatFieldUpdateOperationsInput
  product: ProductUpdateOneWithoutPurchasesInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input PurchaseUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  price: FloatFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input PurchaseUpdateManyWithoutProductInput {
  connect: [PurchaseWhereUniqueInput!]
  connectOrCreate: [PurchaseCreateOrConnectWithoutProductInput!]
  create: [PurchaseCreateWithoutProductInput!]
  createMany: PurchaseCreateManyProductInputEnvelope
  delete: [PurchaseWhereUniqueInput!]
  deleteMany: [PurchaseScalarWhereInput!]
  disconnect: [PurchaseWhereUniqueInput!]
  set: [PurchaseWhereUniqueInput!]
  update: [PurchaseUpdateWithWhereUniqueWithoutProductInput!]
  updateMany: [PurchaseUpdateManyWithWhereWithoutProductInput!]
  upsert: [PurchaseUpsertWithWhereUniqueWithoutProductInput!]
}

input PurchaseUpdateManyWithWhereWithoutProductInput {
  data: PurchaseUpdateManyMutationInput!
  where: PurchaseScalarWhereInput!
}

input PurchaseUpdateWithoutProductInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  price: FloatFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input PurchaseUpdateWithWhereUniqueWithoutProductInput {
  data: PurchaseUpdateWithoutProductInput!
  where: PurchaseWhereUniqueInput!
}

input PurchaseUpsertWithWhereUniqueWithoutProductInput {
  create: PurchaseCreateWithoutProductInput!
  update: PurchaseUpdateWithoutProductInput!
  where: PurchaseWhereUniqueInput!
}

input PurchaseWhereInput {
  AND: [PurchaseWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  NOT: [PurchaseWhereInput!]
  OR: [PurchaseWhereInput!]
  price: FloatFilter
  product: ProductRelationFilter
  productId: StringNullableFilter
  updatedAt: DateTimeFilter
}

input PurchaseWhereUniqueInput {
  id: String
}

type Query {
  aggregateProduct(cursor: ProductWhereUniqueInput, orderBy: [ProductOrderByWithRelationInput!], skip: Int, take: Int, where: ProductWhereInput): AggregateProduct!
  aggregatePurchase(cursor: PurchaseWhereUniqueInput, orderBy: [PurchaseOrderByWithRelationInput!], skip: Int, take: Int, where: PurchaseWhereInput): AggregatePurchase!
  findFirstProduct(cursor: ProductWhereUniqueInput, distinct: [ProductScalarFieldEnum!], orderBy: [ProductOrderByWithRelationInput!], skip: Int, take: Int, where: ProductWhereInput): Product
  findFirstPurchase(cursor: PurchaseWhereUniqueInput, distinct: [PurchaseScalarFieldEnum!], orderBy: [PurchaseOrderByWithRelationInput!], skip: Int, take: Int, where: PurchaseWhereInput): Purchase
  groupByProduct(by: [ProductScalarFieldEnum!]!, having: ProductScalarWhereWithAggregatesInput, orderBy: [ProductOrderByWithAggregationInput!], skip: Int, take: Int, where: ProductWhereInput): [ProductGroupBy!]!
  groupByPurchase(by: [PurchaseScalarFieldEnum!]!, having: PurchaseScalarWhereWithAggregatesInput, orderBy: [PurchaseOrderByWithAggregationInput!], skip: Int, take: Int, where: PurchaseWhereInput): [PurchaseGroupBy!]!
  product(where: ProductWhereUniqueInput!): Product
  products(cursor: ProductWhereUniqueInput, distinct: [ProductScalarFieldEnum!], orderBy: [ProductOrderByWithRelationInput!], skip: Int, take: Int, where: ProductWhereInput): [Product!]!
  purchase(where: PurchaseWhereUniqueInput!): Purchase
  purchases(cursor: PurchaseWhereUniqueInput, distinct: [PurchaseScalarFieldEnum!], orderBy: [PurchaseOrderByWithRelationInput!], skip: Int, take: Int, where: PurchaseWhereInput): [Purchase!]!
}

enum QueryMode {
  default
  insensitive
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableListFilter {
  equals: [String!]
  has: String
  hasEvery: [String!]
  hasSome: [String!]
  isEmpty: Boolean
}

input StringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}
